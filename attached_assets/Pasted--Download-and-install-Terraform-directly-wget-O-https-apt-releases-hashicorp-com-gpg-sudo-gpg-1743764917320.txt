 Download and install Terraform directly
wget -O- https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg
echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
sudo apt update && sudo apt install terraform
# Download and install Terraform directly
wget -O- https://apt.releases.hashicorp.com/gpg | sudo gpg --dearmor -o /usr/share/keyrings/hashicorp-archive-keyring.gpg
echo "deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main" | sudo tee /etc/apt/sources.list.d/hashicorp.list
sudo apt update && sudo apt install terraform
terraform removed
rae@Rae:/mnt/c/Users/KHARDZ/Desktop/Week 3/Oaktree$ # Create a new directory and move your configuration there
rae@Rae:/mnt/c/Users/KHARDZ/Desktop/Week 3/Oaktree$ mkdir -p ~/terraform-project
 * ~/terraform-project/
cd ~/terraform-project

# Set environment variables to help with plugin issues
export TF_PLUGrae@Rae:/mnt/c/Users/KHARDZ/Desktop/Week 3/Oaktree$ cp -r * ~/terraform-project/
IMEOUT=5m
export TF_LOG=DEBUG
export TF_LOG_PATH=terraform.log

# Run terraform directly with increased plugin timeout
terraform init -plugin-dir=$HOME/.terraform.d/plugins -upgrade

^C
rae@Rae:/mnt/c/Users/KHARDZ/Desktop/Week 3/Oaktree$ # Create a new directory for your simple project
 -p ~/srae@Rae:/mnt/c/Users/KHARDZ/Desktop/Week 3/Oaktree$ mkdir -p ~/simple-js-cloud-app
js-cloud-app

# Create a package.json file
cat > package.json << 'EOF'
{
  "narae@Rae:/mnt/c/Users/KHARDZ/Desktop/Week 3/Oaktree$ cd ~/simple-js-cloud-app
simple-js-cloud-app",
  "version": "1.0.0",
  "description": "Simple Node.jrae@Rae:~/simple-js-cloud-app$
rae@Rae:~/simple-js-cloud-app$ # Create a package.json file
rae@Rae:~/simple-js-cloud-app$ cat > package.json << 'EOF'
nt",
  > {
>   "name": "simple-js-cloud-app",
>   "version": "1.0.0",
>   "description": "Simple Node.js app for cloud deployment",
>   "main": "server.js",
>   "scripts": {
>     "start": "node server.js"
  },
  >   },
>   "dependencies": {
>     "express": "^4.18.2"
>   }
F

# > }
> EOF
rae@Rae:~/simple-js-cloud-app$
Create rae@Rae:~/simple-js-cloud-app$ # Create a simple Express server
rae@Rae:~/simple-js-cloud-app$ cat > server.js << 'EOF'
> const express = require('express');
nst app > const app = express();
onst por> const port = process.env.PORT || 3000;
.get('/>
> app.get('/', (req, res) => {
>   res.send(`
 <html>>     <html>
>       <head>
 <title>         <title>Cloud Deployment Success!</title>
>         <style>
>           body {
>             font-family: Arial, sans-serif;
>             margin: 0;
>             padding: 0;
>             display: flex;
>             justify-content: center;
>             align-items: center;
>             height: 100vh;
>             background: linear-gradient(45deg, #0072ff, #00c6ff);
>             color: white;
>             text-align: center;
>           }
>           .container {
>             background: rgba(255, 255, 255, 0.1);
>             padding: 30px;
>             border-radius: 10px;
>             box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
>             max-width: 600px;
>           }
>           h1 {
 font-si>             font-size: 2.5em;
>           }
>         </style>
  </hea>       </head>
>       <body>
>         <div class="container">
        >           <h1>ðŸš€ Cloud Deployment Success!</h1>
        >           <p>Your containerized JavaScript application is running on AWS.</p>
        >           <p>Server time: ${new Date().toLocaleString()}</p>
>           <p>Hostname: ${require('os').hostname()}</p>
>         </div>
>       </body>
>     </html>
>   `);
> });
>
> app.listen(port, () => {
>   console.log(`Server running on port ${port}`);
> });
> EOF
rae@Rae:~/simple-js-cloud-app$
rae@Rae:~/simple-js-cloud-app$ # Create a Dockerfile
rae@Rae:~/simple-js-cloud-app$ cat > Dockerfile << 'EOF'
> FROM node:18-alpine
>
> WORKDIR /app
>
> COPY package*.json ./
> RUN npm install
COPY>
> COPY . .
>
> EXPOSE 3000

CMD >
> CMD ["npm", "start"]
> EOF
rae@Rae:~/simple-js-cloud-app$ # Create Terraform files
rae@Rae:~/simple-js-cloud-app$ cat > main.tf << 'EOF'
> # Configure the AWS Provider
ider "a> provider "aws" {
  region>   region = "ap-southeast-1"
> }
>
> # Create a VPC
> resource "aws_vpc" "app_vpc" {
>   cidr_block = "10.0.0.0/16"
>
>   tags = {
ame = ">     Name = "app-vpc"
>   }
> }
>
> # Create public subnets
> resource "aws_subnet" "public" {
ount = 2>   count = 2
>
>   vpc_id            = aws_vpc.app_vpc.id
>   cidr_block        = "10.0.${count.index}.0/24"
>   availability_zone = "ap-southeast-1${count.index == 0 ? "a" : "b"}"
>   map_public_ip_on_launch = true

  tags >
>   tags = {
 Name =>     Name = "public-subnet-${count.index}"
>   }
> }
>
> # Create Internet Gateway
> resource "aws_internet_gateway" "igw" {
>   vpc_id = aws_vpc.app_vpc.id
 tags = >
>   tags = {
ame = ">     Name = "app-igw"
}

# C>   }
> }
>
> # Create Route Table
> resource "aws_route_table" "public" {
id = aw>   vpc_id = aws_vpc.app_vpc.id
>
>   route {
>     cidr_block = "0.0.0.0/0"
>     gateway_id = aws_internet_gateway.igw.id
>   }
>
>   tags = {
 Name = "public-rt"
  }
}

# Associate Route Table with Subnets
resource "aws>     Name = "public-rt"
>   }
> }
>
> # Associate Route Table with Subnets
> resource "aws_route_table_association" "public" {
>   count = 2
>
net_id >   subnet_id      = aws_subnet.public[count.index].id
>   route_table_id = aws_route_table.public.id
> }
>
> # Create Security Group
> resource "aws_security_group" "app_sg" {
>   name        = "app-sg"
 descrip>   description = "Allow inbound traffic to the application"
pc_id  >   vpc_id      = aws_vpc.app_vpc.id
>
ingress >   ingress {
>     from_port   = 3000
>     to_port     = 3000
>     protocol    = "tcp"
 cidr_b>     cidr_blocks = ["0.0.0.0/0"]
>   }
>
>   egress {
>     from_port   = 0
>     to_port     = 0
  protoc>     protocol    = "-1"
>     cidr_blocks = ["0.0.0.0/0"]
>   }
>
 = {
  >   tags = {
>     Name = "app-sg"

}

#>   }
> }
>
> # Create ECR Repository
> resource "aws_ecr_repository" "app_repo" {
>   name = "simple-js-app"
>
mage_sc>   image_scanning_configuration {
>     scan_on_push = true
>   }
> }
reate E>
> # Create ECS Cluster
"aws_ecs_cluster" "app_cluster" {
  name = "app-cluster"
}

# Create IAM Role for ECS Task Execution
resource "aws_iam_role" "ecs_task_execution_role" {
  name = "ecs-task-execution-r> resource "aws_ecs_cluster" "app_cluster" {
>   name = "app-cluster"
> }
>
> # Create IAM Role for ECS Task Execution
> resource "aws_iam_role" "ecs_task_execution_role" {
>   name = "ecs-task-execution-role"
>
>   assume_role_policy = jsonencode({
rsion = >     Version = "2012-10-17"
>     Statement = [
>       {
>         Action = "sts:AssumeRole"
>         Effect = "Allow"
>         Principal = {
>           Service = "ecs-tasks.amazonaws.com"
>         }
>       }
>     ]
>   })
     = a> }
>
> resource "aws_iam_role_policy_attachment" "ecs_task_execution_role_policy" {
>   role       = aws_iam_role.ecs_task_execution_role.name
>   policy_arn = "arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy"
> }
>
> # Create Task Definition
> resource "aws_ecs_task_definition" "app_task" {
>   family                   = "app-task"
>   network_mode             = "awsvpc"
>   requires_compatibilities = ["FARGATE"]
        >   cpu                      = "256"
>   memory                   = "512"
>   execution_role_arn       = aws_iam_role.ecs_task_execution_role.arn
>
>   container_definitions = jsonencode([
>     {
>       name      = "app-container"
>       image     = "${aws_ecr_repository.app_repo.repository_url}:latest"
>       essential = true
>       portMappings = [
>         {
>           containerPort = 3000
>           hostPort      = 3000
>           protocol      = "tcp"
>         }
>       ]
>       logConfiguration = {
>         logDriver = "awslogs"
>         options = {
>           "awslogs-group"         = "/ecs/app-task"
>           "awslogs-region"        = "ap-southeast-1"
>           "awslogs-stream-prefix" = "ecs"
>         }
>       }
>     }
>   ])
> }
>
> # Create CloudWatch Log Group
> resource "aws_cloudwatch_log_group" "app_logs" {
inition.app_task.arn
  >   name              = "/ecs/app-task"
>   retention_in_days = 7
> }
>
> # Create ECS Service
> resource "aws_ecs_service" "app_service" {
>   name            = "app-service"
>   cluster         = aws_ecs_cluster.app_cluster.id
>   task_definition = aws_ecs_task_definition.app_task.arn
>   desired_count   = 1
>   launch_type     = "FARGATE"
>
>   network_configuration {
>     subnets          = aws_subnet.public.*.id
>     security_groups  = [aws_security_group.app_sg.id]
  assign>     assign_public_ip = true
>   }
> }
>
> # Output the ECR Repository URL
> output "ecr_repository_url" {
>   value = aws_ecr_repository.app_repo.repository_url
> }
>
> # Output the Task Definition ARN
> output "task_definition_arn" {
>   value = aws_ecs_task_definition.app_task.arn
> }
> EOF
rae@Rae:~/simple-js-cloud-app$ terraform init
-bash: /snap/bin/terraform: No such file or directory
rae@Rae:~/simple-js-cloud-app$ terraform plan -out=tfplan
-bash: /snap/bin/terraform: No such file or directory
rae@Rae:~/simple-js-cloud-app$